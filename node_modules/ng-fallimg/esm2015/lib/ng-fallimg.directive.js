/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, HostListener, Inject } from '@angular/core';
import { NG_FALLIMG_SOURCES } from './ng-fallimg-sources';
/**
 * Directive for handling the default image when the main image doesn't works
 */
import * as ɵngcc0 from '@angular/core';
export class NgFallimgDirective {
    /**
     *
     * @param {?} el ElementRef service
     * @param {?} fallimgSources Injector token that contains all the fallback sources
     */
    constructor(el, fallimgSources) {
        this.el = el;
        this.fallimgSources = fallimgSources;
    }
    /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    errorImgHandler() {
        // The chosen source
        /** @type {?} */
        const source = this.fallimgSources[this.fallimg || 'default'];
        // Verify if the key exists in all fallback sources
        if (!source) {
            throw new Error(`ng-fallimg error: ${this.fallimg} doesn't exist as a source or it is an empty source`);
        }
        // it checks if the charged source is different to the actual source, this avoid the infinite bucle creation
        if (source !== this.lastSource) {
            // It saves the last source for matching when the fallback source fails and retried, that avoid an infinite bucle
            this.lastSource = source;
            ((/** @type {?} */ (this.el.nativeElement))).src = source;
        }
    }
}
NgFallimgDirective.ɵfac = function NgFallimgDirective_Factory(t) { return new (t || NgFallimgDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NG_FALLIMG_SOURCES)); };
NgFallimgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgFallimgDirective, selectors: [["img", "fallimg", ""]], hostBindings: function NgFallimgDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("error", function NgFallimgDirective_error_HostBindingHandler() { return ctx.errorImgHandler(); });
    } }, inputs: { fallimg: "fallimg" } });
/** @nocollapse */
NgFallimgDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [NG_FALLIMG_SOURCES,] }] }
];
NgFallimgDirective.propDecorators = {
    fallimg: [{ type: Input, args: ['fallimg',] }],
    errorImgHandler: [{ type: HostListener, args: ['error',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgFallimgDirective, [{
        type: Directive,
        args: [{
                selector: 'img[fallimg]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NG_FALLIMG_SOURCES]
            }] }]; }, { 
    /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    errorImgHandler: [{
            type: HostListener,
            args: ['error']
        }], fallimg: [{
            type: Input,
            args: ['fallimg']
        }] }); })();
if (false) {
    /**
     * Input that receive an optional key for returning the source
     * @type {?}
     */
    NgFallimgDirective.prototype.fallimg;
    /**
     * It contains the last source setted when the main source fails
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.lastSource;
    /**
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.fallimgSources;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctZmFsbGltZy5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIm5nOi9uZy1mYWxsaW1nL2xpYi9uZy1mYWxsaW1nLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkYsT0FBTyxFQUFFLGtCQUFrQixFQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBQzFFO0FBQ0c7QUFDMEU7O0FBTTdFLE1BQU0sT0FBTyxrQkFBa0I7QUFDL0I7QUFFQztBQUFPO0FBQXdDO0FBTXBDO0FBQVEsSUFXbEIsWUFDVSxFQUFjLEVBQ2dCLGNBQThCO0FBQ3JFLFFBRlMsT0FBRSxHQUFGLEVBQUUsQ0FBWTtBQUFDLFFBQ2UsbUJBQWMsR0FBZCxjQUFjLENBQWdCO0FBQ3hFLElBQUssQ0FBQztBQUNOO0FBRUM7QUFDRTtBQUVTO0FBQ047QUFBUSxJQUFKLGVBQWU7QUFBSztBQUVSO0FBQ0EsY0FBWixNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBRSxJQUFJLENBQUMsT0FBTyxJQUFJLFNBQVMsQ0FBRTtBQUNuRSxRQUNJLG1EQUFtRDtBQUN2RCxRQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDakIsWUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFzQixJQUFJLENBQUMsT0FBUSxxREFBcUQsQ0FBQyxDQUFDO0FBQ2hILFNBQUs7QUFDTCxRQUNJLDRHQUE0RztBQUNoSCxRQUFJLElBQUksTUFBTSxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDcEMsWUFDTSxpSEFBaUg7QUFDdkgsWUFBTSxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztBQUMvQixZQUFNLENBQUMsbUJBQUEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQW9CLENBQUMsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDO0FBQy9ELFNBQ0s7QUFDTCxJQUFFLENBQUM7QUFDSDs4Q0FwREMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxjQUFjLGNBQ3pCOzs7MkNBQ0k7QUFBQztBQUFtQjtBQUdHLFlBYlIsVUFBVTtBQUFJLDRDQWdDN0IsTUFBTSxTQUFFLGtCQUFrQjtBQUFRO0FBQUc7QUFFMUMsc0JBbEJHLEtBQUssU0FBQyxTQUFTO0FBQU8sOEJBdUJ0QixZQUFZLFNBQUMsT0FBTztBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUM7QUFBYTtBQUFRO0FBR0s7QUFBaUI7QUFBUSxJQTNCeEQscUNBQXlDO0FBQzNDO0FBRUM7QUFDRTtBQUVVO0FBQWdCO0FBRzdCLElBSEUsd0NBQTJCO0FBQzdCO0FBRUM7QUFDVztBQUFnQjtBQUMxQixJQUlFLGdDQUFzQjtBQUFDO0FBQ3BCO0FBQWlCO0FBQWdCO0FBQVEsSUFBNUMsNENBQW9FO0FBQ3hFO0FBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBIb3N0TGlzdGVuZXIsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfRkFMTElNR19TT1VSQ0VTLCBJRmFsbGltZ1NvdXJjZSB9IGZyb20gJy4vbmctZmFsbGltZy1zb3VyY2VzJztcblxuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIGhhbmRsaW5nIHRoZSBkZWZhdWx0IGltYWdlIHdoZW4gdGhlIG1haW4gaW1hZ2UgZG9lc24ndCB3b3Jrc1xuICovXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2ltZ1tmYWxsaW1nXSdcbn0pXG5leHBvcnQgY2xhc3MgTmdGYWxsaW1nRGlyZWN0aXZlIHtcblxuICAvKipcbiAgICogSW5wdXQgdGhhdCByZWNlaXZlIGFuIG9wdGlvbmFsIGtleSBmb3IgcmV0dXJuaW5nIHRoZSBzb3VyY2VcbiAgICovXG5cbiAgQElucHV0KCdmYWxsaW1nJykgcHVibGljIGZhbGxpbWc6IHN0cmluZztcblxuICAvKipcbiAgICogSXQgY29udGFpbnMgdGhlIGxhc3Qgc291cmNlIHNldHRlZCB3aGVuIHRoZSBtYWluIHNvdXJjZSBmYWlsc1xuICAgKi9cblxuICBwcml2YXRlIGxhc3RTb3VyY2U6IHN0cmluZztcblxuICAvKipcbiAgICogXG4gICAqIEBwYXJhbSBlbCBFbGVtZW50UmVmIHNlcnZpY2VcbiAgICogQHBhcmFtIGZhbGxpbWdTb3VyY2VzIEluamVjdG9yIHRva2VuIHRoYXQgY29udGFpbnMgYWxsIHRoZSBmYWxsYmFjayBzb3VyY2VzXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgQEluamVjdCggTkdfRkFMTElNR19TT1VSQ0VTICkgcHJpdmF0ZSBmYWxsaW1nU291cmNlczogSUZhbGxpbWdTb3VyY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBJdCBoYW5kbGVzIHRoZSBlcnJvciB3aGVuIHRoZSBtYWluIGltYWdlIGRvZXNuJ3QgbG9hZFxuICAgKi9cblxuICBASG9zdExpc3RlbmVyKCdlcnJvcicpXG4gIHByaXZhdGUgZXJyb3JJbWdIYW5kbGVyKCk6IHZvaWQge1xuXG4gICAgLy8gVGhlIGNob3NlbiBzb3VyY2VcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmZhbGxpbWdTb3VyY2VzWyB0aGlzLmZhbGxpbWcgfHwgJ2RlZmF1bHQnIF07XG5cbiAgICAvLyBWZXJpZnkgaWYgdGhlIGtleSBleGlzdHMgaW4gYWxsIGZhbGxiYWNrIHNvdXJjZXNcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBuZy1mYWxsaW1nIGVycm9yOiAkeyB0aGlzLmZhbGxpbWcgfSBkb2Vzbid0IGV4aXN0IGFzIGEgc291cmNlIG9yIGl0IGlzIGFuIGVtcHR5IHNvdXJjZWApO1xuICAgIH1cblxuICAgIC8vIGl0IGNoZWNrcyBpZiB0aGUgY2hhcmdlZCBzb3VyY2UgaXMgZGlmZmVyZW50IHRvIHRoZSBhY3R1YWwgc291cmNlLCB0aGlzIGF2b2lkIHRoZSBpbmZpbml0ZSBidWNsZSBjcmVhdGlvblxuICAgIGlmIChzb3VyY2UgIT09IHRoaXMubGFzdFNvdXJjZSkge1xuXG4gICAgICAvLyBJdCBzYXZlcyB0aGUgbGFzdCBzb3VyY2UgZm9yIG1hdGNoaW5nIHdoZW4gdGhlIGZhbGxiYWNrIHNvdXJjZSBmYWlscyBhbmQgcmV0cmllZCwgdGhhdCBhdm9pZCBhbiBpbmZpbml0ZSBidWNsZVxuICAgICAgdGhpcy5sYXN0U291cmNlID0gc291cmNlO1xuICAgICAgKHRoaXMuZWwubmF0aXZlRWxlbWVudCBhcyBIVE1MSW1hZ2VFbGVtZW50KS5zcmMgPSBzb3VyY2U7XG4gICAgICBcbiAgICB9XG4gIH1cbn1cbiJdfQ==