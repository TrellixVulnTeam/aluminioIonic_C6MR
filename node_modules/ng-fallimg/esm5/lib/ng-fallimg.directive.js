/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, HostListener, Inject } from '@angular/core';
import { NG_FALLIMG_SOURCES } from './ng-fallimg-sources';
/**
 * Directive for handling the default image when the main image doesn't works
 */
import * as ɵngcc0 from '@angular/core';
var NgFallimgDirective = /** @class */ (function () {
    /**
     *
     * @param el ElementRef service
     * @param fallimgSources Injector token that contains all the fallback sources
     */
    function NgFallimgDirective(el, fallimgSources) {
        this.el = el;
        this.fallimgSources = fallimgSources;
    }
    /**
     * It handles the error when the main image doesn't load
     */
    /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    NgFallimgDirective.prototype.errorImgHandler = /**
     * It handles the error when the main image doesn't load
     * @private
     * @return {?}
     */
    function () {
        // The chosen source
        /** @type {?} */
        var source = this.fallimgSources[this.fallimg || 'default'];
        // Verify if the key exists in all fallback sources
        if (!source) {
            throw new Error("ng-fallimg error: " + this.fallimg + " doesn't exist as a source or it is an empty source");
        }
        // it checks if the charged source is different to the actual source, this avoid the infinite bucle creation
        if (source !== this.lastSource) {
            // It saves the last source for matching when the fallback source fails and retried, that avoid an infinite bucle
            this.lastSource = source;
            ((/** @type {?} */ (this.el.nativeElement))).src = source;
        }
    };
    /** @nocollapse */
    NgFallimgDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [NG_FALLIMG_SOURCES,] }] }
    ]; };
    NgFallimgDirective.propDecorators = {
        fallimg: [{ type: Input, args: ['fallimg',] }],
        errorImgHandler: [{ type: HostListener, args: ['error',] }]
    };
NgFallimgDirective.ɵfac = function NgFallimgDirective_Factory(t) { return new (t || NgFallimgDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NG_FALLIMG_SOURCES)); };
NgFallimgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgFallimgDirective, selectors: [["img", "fallimg", ""]], hostBindings: function NgFallimgDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("error", function NgFallimgDirective_error_HostBindingHandler() { return ctx.errorImgHandler(); });
    } }, inputs: { fallimg: "fallimg" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgFallimgDirective, [{
        type: Directive,
        args: [{
                selector: 'img[fallimg]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NG_FALLIMG_SOURCES]
            }] }]; }, { errorImgHandler: [{
            type: HostListener,
            args: ['error']
        }], fallimg: [{
            type: Input,
            args: ['fallimg']
        }] }); })();
    return NgFallimgDirective;
}());
export { NgFallimgDirective };
if (false) {
    /**
     * Input that receive an optional key for returning the source
     * @type {?}
     */
    NgFallimgDirective.prototype.fallimg;
    /**
     * It contains the last source setted when the main source fails
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.lastSource;
    /**
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgFallimgDirective.prototype.fallimgSources;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctZmFsbGltZy5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIm5nOi9uZy1mYWxsaW1nL2xpYi9uZy1mYWxsaW1nLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkYsT0FBTyxFQUFFLGtCQUFrQixFQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBQzFFO0FBQ0c7QUFDMEU7O0FBRzdFO0FBR1csSUFjVDtBQUNGO0FBQ0M7QUFDRTtBQUNFLE9BQUE7QUFDTCxJQUNFLDRCQUNVLEVBQWMsRUFDZ0IsY0FBOEI7QUFDckUsUUFGUyxPQUFFLEdBQUYsRUFBRSxDQUFZO0FBQUMsUUFDZSxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7QUFDeEUsSUFBSyxDQUFDO0FBQ04sSUFDRTtBQUNGO0FBQ0UsT0FBRztBQUNMO0FBQ087QUFHRDtBQUFnQjtBQUNOO0FBQVEsSUFIZCw0Q0FBZTtBQUFPO0FBR0Q7QUFBZ0I7QUFBbUI7QUFFOUQsSUFORjtBQUFjO0FBQ0k7QUFFWixZQUNFLE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFFLElBQUksQ0FBQyxPQUFPLElBQUksU0FBUyxDQUFFO0FBQ25FLFFBQ0ksbURBQW1EO0FBQ3ZELFFBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNqQixZQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXNCLElBQUksQ0FBQyxPQUFPLHdEQUFzRCxDQUFDLENBQUM7QUFDaEgsU0FBSztBQUNMLFFBQ0ksNEdBQTRHO0FBQ2hILFFBQUksSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNwQyxZQUNNLGlIQUFpSDtBQUN2SCxZQUFNLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDO0FBQy9CLFlBQU0sQ0FBQyxtQkFBQSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBb0IsQ0FBQyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7QUFDL0QsU0FDSztBQUNMLElBQUUsQ0FBQyxDQWhETTtBQUFDOytCQUhULFNBQVMsU0FBQyxqREFHc0I7UUFGL0IsUUFBUSxFQUFFLGxCQUsyQyxnQkFibkMsVUFBVTtFQVFKLGtCQUN6QixwQkFUaUMsZ0RBZ0M3QixNQUFNLFNBQUUsa0JBQWtCO0FBQVE7QUFBVTtBQUk3QywwQkFwQkQsS0FBSyxTQUFDLFNBQVM7QUFBTyxrQ0F1QnRCLFlBQVksU0FBQyxPQUFPO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQUMsSUFtQlgseUJBQUM7QUFDQSxDQURBLEFBcERELElBb0RDO0FBQ0QsU0FsRGEsa0JBQWtCO0FBRS9CO0FBQ087QUFBUTtBQUdMO0FBQWlCO0FBQVEsSUFBakMscUNBQXlDO0FBQzNDO0FBRUM7QUFDRTtBQUVVO0FBQWdCO0FBRzdCLElBSEUsd0NBQTJCO0FBQzdCO0FBRUM7QUFDVztBQUFnQjtBQUMxQixJQUlFLGdDQUFzQjtBQUFDO0FBQ3BCO0FBQWlCO0FBQWdCO0FBQVEsSUFBNUMsNENBQW9FO0FBQ3hFO0FBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBIb3N0TGlzdGVuZXIsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfRkFMTElNR19TT1VSQ0VTLCBJRmFsbGltZ1NvdXJjZSB9IGZyb20gJy4vbmctZmFsbGltZy1zb3VyY2VzJztcblxuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIGhhbmRsaW5nIHRoZSBkZWZhdWx0IGltYWdlIHdoZW4gdGhlIG1haW4gaW1hZ2UgZG9lc24ndCB3b3Jrc1xuICovXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2ltZ1tmYWxsaW1nXSdcbn0pXG5leHBvcnQgY2xhc3MgTmdGYWxsaW1nRGlyZWN0aXZlIHtcblxuICAvKipcbiAgICogSW5wdXQgdGhhdCByZWNlaXZlIGFuIG9wdGlvbmFsIGtleSBmb3IgcmV0dXJuaW5nIHRoZSBzb3VyY2VcbiAgICovXG5cbiAgQElucHV0KCdmYWxsaW1nJykgcHVibGljIGZhbGxpbWc6IHN0cmluZztcblxuICAvKipcbiAgICogSXQgY29udGFpbnMgdGhlIGxhc3Qgc291cmNlIHNldHRlZCB3aGVuIHRoZSBtYWluIHNvdXJjZSBmYWlsc1xuICAgKi9cblxuICBwcml2YXRlIGxhc3RTb3VyY2U6IHN0cmluZztcblxuICAvKipcbiAgICogXG4gICAqIEBwYXJhbSBlbCBFbGVtZW50UmVmIHNlcnZpY2VcbiAgICogQHBhcmFtIGZhbGxpbWdTb3VyY2VzIEluamVjdG9yIHRva2VuIHRoYXQgY29udGFpbnMgYWxsIHRoZSBmYWxsYmFjayBzb3VyY2VzXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgQEluamVjdCggTkdfRkFMTElNR19TT1VSQ0VTICkgcHJpdmF0ZSBmYWxsaW1nU291cmNlczogSUZhbGxpbWdTb3VyY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBJdCBoYW5kbGVzIHRoZSBlcnJvciB3aGVuIHRoZSBtYWluIGltYWdlIGRvZXNuJ3QgbG9hZFxuICAgKi9cblxuICBASG9zdExpc3RlbmVyKCdlcnJvcicpXG4gIHByaXZhdGUgZXJyb3JJbWdIYW5kbGVyKCk6IHZvaWQge1xuXG4gICAgLy8gVGhlIGNob3NlbiBzb3VyY2VcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmZhbGxpbWdTb3VyY2VzWyB0aGlzLmZhbGxpbWcgfHwgJ2RlZmF1bHQnIF07XG5cbiAgICAvLyBWZXJpZnkgaWYgdGhlIGtleSBleGlzdHMgaW4gYWxsIGZhbGxiYWNrIHNvdXJjZXNcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBuZy1mYWxsaW1nIGVycm9yOiAkeyB0aGlzLmZhbGxpbWcgfSBkb2Vzbid0IGV4aXN0IGFzIGEgc291cmNlIG9yIGl0IGlzIGFuIGVtcHR5IHNvdXJjZWApO1xuICAgIH1cblxuICAgIC8vIGl0IGNoZWNrcyBpZiB0aGUgY2hhcmdlZCBzb3VyY2UgaXMgZGlmZmVyZW50IHRvIHRoZSBhY3R1YWwgc291cmNlLCB0aGlzIGF2b2lkIHRoZSBpbmZpbml0ZSBidWNsZSBjcmVhdGlvblxuICAgIGlmIChzb3VyY2UgIT09IHRoaXMubGFzdFNvdXJjZSkge1xuXG4gICAgICAvLyBJdCBzYXZlcyB0aGUgbGFzdCBzb3VyY2UgZm9yIG1hdGNoaW5nIHdoZW4gdGhlIGZhbGxiYWNrIHNvdXJjZSBmYWlscyBhbmQgcmV0cmllZCwgdGhhdCBhdm9pZCBhbiBpbmZpbml0ZSBidWNsZVxuICAgICAgdGhpcy5sYXN0U291cmNlID0gc291cmNlO1xuICAgICAgKHRoaXMuZWwubmF0aXZlRWxlbWVudCBhcyBIVE1MSW1hZ2VFbGVtZW50KS5zcmMgPSBzb3VyY2U7XG4gICAgICBcbiAgICB9XG4gIH1cbn1cbiJdfQ==