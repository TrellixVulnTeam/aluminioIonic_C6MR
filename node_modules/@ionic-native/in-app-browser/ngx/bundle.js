'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var core = require('@angular/core');
var core$1 = require('@ionic-native/core');
var rxjs = require('rxjs');

var ɵngcc0 = require('@angular/core');
var InAppBrowserObject = /** @class */ (function () {
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     * @param {string} url     The URL to load.
     * @param {string} [target="self"]  The target in which to load the URL, an optional parameter that defaults to _self.
     *                 _self: Opens in the WebView if the URL is in the white list, otherwise it opens in the InAppBrowser.
     *                 _blank: Opens in the InAppBrowser.
     *                 _system: Opens in the system's web browser.
     * @param {string | InAppBrowserOptions} [options] Options for the InAppBrowser. Optional, defaulting to: location=yes.
     *                 The options string must not contain any blank space, and each feature's
     *                 name/value pairs must be separated by a comma. Feature names are case insensitive.
     */
    function InAppBrowserObject(url, target, options) {
        try {
            if (options && typeof options !== 'string') {
                options = Object.keys(options)
                    .map(function (key) { return key + "=" + options[key]; })
                    .join(',');
            }
            this._objectInstance = cordova.InAppBrowser.open(url, target, options);
        }
        catch (e) {
            if (typeof window !== 'undefined') {
                window.open(url, target);
            }
            console.warn('Native: InAppBrowser is not installed or you are running on a browser. Falling back to window.open.');
        }
    }
    InAppBrowserObject.prototype._loadAfterBeforeload = function (strUrl) { return core$1.cordovaInstance(this, "_loadAfterBeforeload", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.show = function () { return core$1.cordovaInstance(this, "show", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.close = function () { return core$1.cordovaInstance(this, "close", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.hide = function () { return core$1.cordovaInstance(this, "hide", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.executeScript = function (script) { return core$1.cordovaInstance(this, "executeScript", {}, arguments); };
    InAppBrowserObject.prototype.insertCSS = function (css) { return core$1.cordovaInstance(this, "insertCSS", {}, arguments); };
    InAppBrowserObject.prototype.on = function (event) {
        var _this = this;
        return (function () {
            if (core$1.instanceAvailability(_this) === true) {
                return new rxjs.Observable(function (observer) {
                    _this._objectInstance.addEventListener(event, observer.next.bind(observer));
                    return function () { return _this._objectInstance.removeEventListener(event, observer.next.bind(observer)); };
                });
            }
        })();
    };
    InAppBrowserObject.prototype.on = function (event) {
        var _this = this;
        return (function () {
            if (core$1.instanceAvailability(_this) === true) {
                return new rxjs.Observable(function (observer) {
                    _this._objectInstance.addEventListener(event, observer.next.bind(observer));
                    return function () { return _this._objectInstance.removeEventListener(event, observer.next.bind(observer)); };
                });
            }
        })();
    };
    return InAppBrowserObject;
}());
var InAppBrowser = /** @class */ (function (_super) {
    tslib.__extends(InAppBrowser, _super);
    function InAppBrowser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     * @param  url {string}     The URL to load.
     * @param  target {string}  The target in which to load the URL, an optional parameter that defaults to _self.
     * @param  options {string} Options for the InAppBrowser. Optional, defaulting to: location=yes.
     *                 The options string must not contain any blank space, and each feature's
     *                 name/value pairs must be separated by a comma. Feature names are case insensitive.
     * @returns {InAppBrowserObject}
     */
    InAppBrowser.prototype.create = function (url, target, options) {
        return new InAppBrowserObject(url, target, options);
    };
    InAppBrowser.pluginName = "InAppBrowser";
    InAppBrowser.plugin = "cordova-plugin-inappbrowser";
    InAppBrowser.pluginRef = "cordova.InAppBrowser";
    InAppBrowser.repo = "https://github.com/apache/cordova-plugin-inappbrowser";
    InAppBrowser.platforms = ["AmazonFire OS", "Android", "Browser", "iOS", "macOS", "Windows"];
InAppBrowser.ɵfac = function InAppBrowser_Factory(t) { return ɵInAppBrowser_BaseFactory(t || InAppBrowser); };
InAppBrowser.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InAppBrowser, factory: function (t) { return InAppBrowser.ɵfac(t); } });
var ɵInAppBrowser_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(InAppBrowser);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InAppBrowser, [{
        type: core.Injectable
    }], null, null); })();
    return InAppBrowser;
}(core$1.IonicNativePlugin));

exports.InAppBrowser = InAppBrowser;
exports.InAppBrowserObject = InAppBrowserObject;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswQkFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlJDEgPSByZXF1aXJlKCdAaW9uaWMtbmF0aXZlL2NvcmUnKTtcbnZhciByeGpzID0gcmVxdWlyZSgncnhqcycpO1xuXG52YXIgSW5BcHBCcm93c2VyT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgVVJMIGluIGEgbmV3IEluQXBwQnJvd3NlciBpbnN0YW5jZSwgdGhlIGN1cnJlbnQgYnJvd3NlciBpbnN0YW5jZSwgb3IgdGhlIHN5c3RlbSBicm93c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgIFRoZSBVUkwgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldD1cInNlbGZcIl0gIFRoZSB0YXJnZXQgaW4gd2hpY2ggdG8gbG9hZCB0aGUgVVJMLCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZWZhdWx0cyB0byBfc2VsZi5cbiAgICAgKiAgICAgICAgICAgICAgICAgX3NlbGY6IE9wZW5zIGluIHRoZSBXZWJWaWV3IGlmIHRoZSBVUkwgaXMgaW4gdGhlIHdoaXRlIGxpc3QsIG90aGVyd2lzZSBpdCBvcGVucyBpbiB0aGUgSW5BcHBCcm93c2VyLlxuICAgICAqICAgICAgICAgICAgICAgICBfYmxhbms6IE9wZW5zIGluIHRoZSBJbkFwcEJyb3dzZXIuXG4gICAgICogICAgICAgICAgICAgICAgIF9zeXN0ZW06IE9wZW5zIGluIHRoZSBzeXN0ZW0ncyB3ZWIgYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IEluQXBwQnJvd3Nlck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgSW5BcHBCcm93c2VyLiBPcHRpb25hbCwgZGVmYXVsdGluZyB0bzogbG9jYXRpb249eWVzLlxuICAgICAqICAgICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgYmxhbmsgc3BhY2UsIGFuZCBlYWNoIGZlYXR1cmUnc1xuICAgICAqICAgICAgICAgICAgICAgICBuYW1lL3ZhbHVlIHBhaXJzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIEZlYXR1cmUgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5BcHBCcm93c2VyT2JqZWN0KHVybCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgKyBcIj1cIiArIG9wdGlvbnNba2V5XTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29iamVjdEluc3RhbmNlID0gY29yZG92YS5JbkFwcEJyb3dzZXIub3Blbih1cmwsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmF0aXZlOiBJbkFwcEJyb3dzZXIgaXMgbm90IGluc3RhbGxlZCBvciB5b3UgYXJlIHJ1bm5pbmcgb24gYSBicm93c2VyLiBGYWxsaW5nIGJhY2sgdG8gd2luZG93Lm9wZW4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5fbG9hZEFmdGVyQmVmb3JlbG9hZCA9IGZ1bmN0aW9uIChzdHJVcmwpIHsgcmV0dXJuIGNvcmUkMS5jb3Jkb3ZhSW5zdGFuY2UodGhpcywgXCJfbG9hZEFmdGVyQmVmb3JlbG9hZFwiLCB7IFwic3luY1wiOiB0cnVlIH0sIGFyZ3VtZW50cyk7IH07XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZSQxLmNvcmRvdmFJbnN0YW5jZSh0aGlzLCBcInNob3dcIiwgeyBcInN5bmNcIjogdHJ1ZSB9LCBhcmd1bWVudHMpOyB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlJDEuY29yZG92YUluc3RhbmNlKHRoaXMsIFwiY2xvc2VcIiwgeyBcInN5bmNcIjogdHJ1ZSB9LCBhcmd1bWVudHMpOyB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUkMS5jb3Jkb3ZhSW5zdGFuY2UodGhpcywgXCJoaWRlXCIsIHsgXCJzeW5jXCI6IHRydWUgfSwgYXJndW1lbnRzKTsgfTtcbiAgICBJbkFwcEJyb3dzZXJPYmplY3QucHJvdG90eXBlLmV4ZWN1dGVTY3JpcHQgPSBmdW5jdGlvbiAoc2NyaXB0KSB7IHJldHVybiBjb3JlJDEuY29yZG92YUluc3RhbmNlKHRoaXMsIFwiZXhlY3V0ZVNjcmlwdFwiLCB7fSwgYXJndW1lbnRzKTsgfTtcbiAgICBJbkFwcEJyb3dzZXJPYmplY3QucHJvdG90eXBlLmluc2VydENTUyA9IGZ1bmN0aW9uIChjc3MpIHsgcmV0dXJuIGNvcmUkMS5jb3Jkb3ZhSW5zdGFuY2UodGhpcywgXCJpbnNlcnRDU1NcIiwge30sIGFyZ3VtZW50cyk7IH07XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjb3JlJDEuaW5zdGFuY2VBdmFpbGFiaWxpdHkoX3RoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vYmplY3RJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vYmplY3RJbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpKTsgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY29yZSQxLmluc3RhbmNlQXZhaWxhYmlsaXR5KF90aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb2JqZWN0SW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb2JqZWN0SW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5BcHBCcm93c2VyT2JqZWN0O1xufSgpKTtcbnZhciBJbkFwcEJyb3dzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEluQXBwQnJvd3NlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbkFwcEJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBVUkwgaW4gYSBuZXcgSW5BcHBCcm93c2VyIGluc3RhbmNlLCB0aGUgY3VycmVudCBicm93c2VyIGluc3RhbmNlLCBvciB0aGUgc3lzdGVtIGJyb3dzZXIuXG4gICAgICogQHBhcmFtICB1cmwge3N0cmluZ30gICAgIFRoZSBVUkwgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0gIHRhcmdldCB7c3RyaW5nfSAgVGhlIHRhcmdldCBpbiB3aGljaCB0byBsb2FkIHRoZSBVUkwsIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRlZmF1bHRzIHRvIF9zZWxmLlxuICAgICAqIEBwYXJhbSAgb3B0aW9ucyB7c3RyaW5nfSBPcHRpb25zIGZvciB0aGUgSW5BcHBCcm93c2VyLiBPcHRpb25hbCwgZGVmYXVsdGluZyB0bzogbG9jYXRpb249eWVzLlxuICAgICAqICAgICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgYmxhbmsgc3BhY2UsIGFuZCBlYWNoIGZlYXR1cmUnc1xuICAgICAqICAgICAgICAgICAgICAgICBuYW1lL3ZhbHVlIHBhaXJzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIEZlYXR1cmUgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAgICogQHJldHVybnMge0luQXBwQnJvd3Nlck9iamVjdH1cbiAgICAgKi9cbiAgICBJbkFwcEJyb3dzZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh1cmwsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEluQXBwQnJvd3Nlck9iamVjdCh1cmwsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBJbkFwcEJyb3dzZXIucGx1Z2luTmFtZSA9IFwiSW5BcHBCcm93c2VyXCI7XG4gICAgSW5BcHBCcm93c2VyLnBsdWdpbiA9IFwiY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyXCI7XG4gICAgSW5BcHBCcm93c2VyLnBsdWdpblJlZiA9IFwiY29yZG92YS5JbkFwcEJyb3dzZXJcIjtcbiAgICBJbkFwcEJyb3dzZXIucmVwbyA9IFwiaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9jb3Jkb3ZhLXBsdWdpbi1pbmFwcGJyb3dzZXJcIjtcbiAgICBJbkFwcEJyb3dzZXIucGxhdGZvcm1zID0gW1wiQW1hem9uRmlyZSBPU1wiLCBcIkFuZHJvaWRcIiwgXCJCcm93c2VyXCIsIFwiaU9TXCIsIFwibWFjT1NcIiwgXCJXaW5kb3dzXCJdO1xuICAgIEluQXBwQnJvd3Nlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmUuSW5qZWN0YWJsZSB9XG4gICAgXTtcbiAgICByZXR1cm4gSW5BcHBCcm93c2VyO1xufShjb3JlJDEuSW9uaWNOYXRpdmVQbHVnaW4pKTtcblxuZXhwb3J0cy5JbkFwcEJyb3dzZXIgPSBJbkFwcEJyb3dzZXI7XG5leHBvcnRzLkluQXBwQnJvd3Nlck9iamVjdCA9IEluQXBwQnJvd3Nlck9iamVjdDtcbiJdfQ==